\documentclass[a4paper,10pt]{article}

\usepackage[latin2]{inputenc}
\usepackage[hungarian]{babel}
\usepackage{t1enc}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{url}

%opening
\title{Hello Window! - GTK+/gtkmm programozás GNU/Linux alatt}
\author{Pfeiffer Szilárd}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
A \textit{GTK+} (\textit{GIMP Toolkit}) egy \textit{C} nyelven -- ám objektum-orientált megközelítéssel -- íródott, grafikus felhasználói felületek (\textit{GUI}) létrehozására használatos alkalmazás-programozási interfész. A \textit{gtkmm} nem más, mint ennek a függvénykönyvtárnak a \textit{C++} változata, pontosabban fogalmazva \textit{wrapper}e. Mindkét függvénykönyvtár terjesztése \textit{LGPL} licenc alatt történik, így bátran felhasználható mind szabad/ingyenes, mind kereskedelmi szoftverek létrehozására.

A most kezd¿d¿ sorozat célja az abszolút kezdetekt¿l indulva bemutatni a \textit{GTK+} és a \textit{gtkmm} hasonlóságait, különböz¿ségeit, sajátosságait eljutva egy olyan szintre, ahol remélhet¿leg a több éves tapasztalattal rendelkez¿ fejleszt¿k is találnak hasznos, megfontolásra érdemes ötleteket, információkat.
\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Bevezetés}

A cikksorozat második részében az elsõ alkalommal már bemutatott példaprogramokat újra felhasználva a \textit{GTK+}/\textit{gtkmm} programozás azon területeit vesszük sorra, melyek nélkül rövid távon el lehet boldogulni, de nélkülözhetetlenek az alapos megértést igénylõ feladatok megoldásához.

\subsection{Alapfogalmak}

Még mielõtt ismertetnénk néhány alapfogalmat érdemes kitérni arra, hogy ezen túl a \textit{GTK} rövidítést akkor használjuk, ha a felületprogramozási nyelvrõl általánosságban szólunk, míg a \textit{GTK+} és \textit{gtkmm} kifejezések a konkrét \textit{C}, illetve \textit{C++} nyelvû implementációkat jelölik.

\subsubsection{Objektum-orientált megközelítés}

\begin{description}
 \item[Öröklõdés] Annak ellenére, hogy a mechanizmust nyelvi szinten a \textit{C} nem, csak a \textit{C++} támogatja igen is lehetséges objektum-orientált megközelítéssel élni az elsõ esetben is. Erre kitûnõ példa --egyebek mellett-- a \textit{GTK+}. Megoldott a \textit{widget}ek egymásból történõ származtatása, sõt felhasználói widgetek is definiálhatóak a már meglévõekre támaszkodva. Meg kell jegyezni, hogy a \textit{gtkmm} esetén --lévén ott a nyelv \textit{C++}-- természetesen a származtatás egy nagyságrenddel egyszerûbb, de a letölthetõ példákat felhasználva némi rutinnal a \textit{GTK+} esetén sem igényel különösebb erõfeszítést.

 \item[Típusbiztosság] Hasonlóan a korábbiakhoz pusztán nyelvi szinten ez az eszköz sem megvalósítható (\textit{C} esetén), ugyanakkor a \textit{GTK+} minden \textit{widget}típushoz --mondhatni osztályhoz-- definiál egy-egy makrót, melyek segítségével, fordítási idõben (compile time) ugyan nem, de futásidõben (run time) ellenõrizhetõ egy adott widget valódi típus, hasonlóan ahhoz, mint amire a \textit{dynamic\_cast} használata jelent a \textit{C++}-ban.
\end{description}

Fentieket figyelembe véve láthatjuk, hogy a \textit{GTK+} ugyan \textit{C} nyelven íródott, de számos --az objektum-orientált-- nyelvek esetén megszokott terminológiát használ, sõt ezeket a nylevi eszközök adta mértékben meg is valósítja. Az \textit{OOP} kifejezéseit ezért tudatosan használom az olyan esetekben is, ahol \textit{GTK+} nyelvû fejlesztésrõl esik szó.

\subsubsection{Felületprogramozási kulcsszavak}

\begin{description}
 \item[Widget] A kifejezést, mint gyûjtõfogalmat használjuk a \textit{GTK} programozás során a felhasználó felület egyes grafikai elemeinek megnevezésére. Az elnevezés egyébiránt az \textit{X} hagyományokból eredeztethetõ. A szó azonban nem csak erre szolgál, hanem annak az õsosztálynak a neve is --még ha ez a fogalom \textit{C} nyelvben nem is létezik-- melybõl minden egyes megjeleníthetõ elem --gomb, menü, csúszka-- származik.

 \item[GTK Main Loop] Ez a \textit{GTK} tulajdonképpeni fõciklusa, mely a \textit{Glib}ben implementál általános \textit{main loop}ot felhasználva csatlakozik a \textit{X} szerverhez. Mindezt a \textit{GDK}-n keresztül teszi, mely --mint azt az elõzõ részben is említettük-- egy burkoló réteg az ablakozó rendszer köré. Ezt azért fontos kiemelni, mert ezzel a módszerrel biztosítható, hogy a \textit{GTK} mûködõképes legyen különbözõ grafikus szerverek (\textit{X}, \textit{framebuffer}) és platformokon (\textit{GNU/Linux}, \textit{Windows}, \textit{Mac OS X}) futtatása mellett egyaránt. A \textit{main loop} tehát az aki az imént említett kapcsolaton át eljuttatja az ablakozó rendszer alacsony szintû eseményeit a \textit{GDK} által standardizált formában az egyes \textit{widget}ekhez.

 \item[Signal] A \textit{GTK}, és egyébiránt minden más felületprogramozási nyelv, egyik kulcsszava. Jelentése (jel, jelzés) jól tükrözi funkcióját. Minden \textit{widget}hez tartoz(hat)nak különbözõ események --mint amilyen egy gomb esetén annak lenyomása (vagy éppen felengedése), egy beviteli mezõnél az abba történõ írás-- melyekrõl a widgetek tudomást szereznek --egyébként a \textit{main loop}on keresztül-- elvégzik a megfelelõ mûveleteket --gomb lenyomásnál újrarajzolás, beviteli mezõbe írásnál a karakter megjelenítése-- majd értesítést küldenek a program többi része felé. Ezt az értesítést, avagy jelzést nevezzük \textit{signal}nek.

 \item[Callback] Amennyiben egy adott \textit{widget} által küldött meghatározott eseményrõl tudomást akarunk szerezni a program futása során, ezt megtehetjük azáltal, hogy a \textit{widget} megfelelõ \textit{signal}jéhez egy \textit{callback}et, azaz eseménykezelõ függvény társítunk. Itt minden olyan esemény elvégezhetõ, mely nem a \textit{widget}hez, hanem annak programunkban betöltött szerepéhez kötõdik. A korábbi példánál maradva ez egy \textit{Szerkesztés} gomb lenyomásánál lehet egy dialógus ablak megjelenítése, egy beviteli mezõbe való írásnál --amennyiben ez szükséges-- a tartalom ellenõrzése.
\end{description}

Az utóbbi két fogalom, mivel a \textit{GUI}-k fejlesztése tulajdonképpen eseményvezérelt programozás, kiemelt fontosságú. Ennek okán errõl a következõ részben részletesebben is kívánunk szólni. Elöljáróban csak annyit, hogy a \textit{GTK} lehetõséget ad a \textit{signal}ek \textit{widgetek}tõl teljesen független használatára is, azaz akár saját osztályainkhoz is rendelhetünk eseményeket. Ez azonban már túlmutat ennek a résznek a keretein...

\subsubsection{A megvalósítás}

Az elõzõ fejezetekben olvasható metodikák és módszerek közül a \textit{GTK} \texttt{GObject}, avagy \texttt{Glib::Object} osztálya az alábbiakat valósítja meg:

\begin{description}
 \item[Öröklõdés] Az \textit{oject} osztály típus minden \textit{widget}, és egy más a \textit{GTK}-ban használt nem vizuális elem õse.

 \item[Típusbiztosság] Ez az osztály implementálja azt a mechanizmust, melynek segítségével lehetõvé válik a \textit{GTK+}-ban a futás idejû típusellenõrzés.

 \item[Signal] Ezen osztályon keresztül valósul meg a szignálkezelés, mely lehetõvé teszi adott eseményekhez kezelõfüggvények (\textit{callback}) kapcsolását. Itt kell megjegyezni, hogy mivel az object nem csupán a \textit{widget}eknek õse, így olyan \textit{GTK}-s, vagy akár saját, elemeknek is lehetnek szignáljai, melyek közvetlenül nem láthatóak, mint az általunk létrehozott \textit{GUI} részei.

 \item[Referencia-számlálás] Minden \textit{object}bõl származó osztály, így a widgetek is, rendelkeznek referencia-számmal, mely tulajdonképpen azt fejezi ki, hogy hányan hivatkoznak az adott elemre. A \textit{GTK}, pontosabban ez esetben a \textit{GLib} lebegõ referenciát (\textit{floating reference}) alkalmaz, mely azt jelenti, hogy az objektum létrejöttekor annak referenciája 1 lesz, de ezt a referenciát úgymond nem birtokolja senki, azaz ha a \textit{widget}et egy konténer osztályba (melyekrõl részletesebben a következõ rész szól majd) kívánjuk tenni, akkor --az elsõ ilyen alkalommal-- a refernciaszám nem nõ, annak ellenére sem, hogy ez valójában hivatkozást jelent az adott elemre. A változatlanul hagyott referencia-érték jelenti a lebegõ referencia elsûllyesztését (\textit{sink}). Minden azt követõ esetben a konténerbõl történõ eltávolítás csökkenti, ahoz való hozzáadás pedig növeli a referencia értékét. Érdemes felhívni a figyelmet arra, hogy az elmondottak alapján, ha hozzáadtuk \textit{widget}ünket egy \textit{container}hez, majd pedig eltávolítjuk belõle azt, akkor annak referenciája 0-ra csökken, ami maga után vonja a destruktor lefutását. Ezt elkerülhetjük, ha az eltávolítás elõtt explicit módon növeljük a referenciát, amit aztán csökkentenünk kell, ha egy másik osztály ``birtokába'' adjuk a \textit{widget}et.
\end{description}

\section{Elsõ ablakunk háttere}

\subsection{A kód}

Az ismétlés kedvéért --no meg persze, hogy kéznél legyen-- lássuk most az elõzõ számban már bemutatott példaprogramokat.

\vspace{16pt}
\fontsize{8pt}{8pt}
\begin{verbatim}
1  #include <gtk/gtk.h>                             #include <gtkmm.h>
2
3  int main(int argc, char *argv[])                 int main(int argc, char *argv[])
4  {                                                {
5    GtkWidget *window;
6
7    gtk_init (&argc, &argv);                         Gtk::Main kit(argc, argv);
8
9    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);   Gtk::Window window;
10   gtk_widget_show  (window);
11
12   gtk_main ();                                     Gtk::Main::run(window);
13
14   return 0;                                        return 0;
15 }                                                }
\end{verbatim} 

A fenti példaprogramok \textit{C/C++} nyelvû forrásfájljai, illetve azok eredetijei, a \textit{FLOSSzine}, valamint a \textit{GTK+}/\textit{gtkmm} oldalain az alábbi linkeken érhetõek el:
\ \\\\
\url{http://www.flosszine.org/sources/gtk_window.c}\\
\url{http://www.flosszine.org/sources/gtkmm_window.cc}\\
\url{http://library.gnome.org/devel/gtk-tutorial/stable/c39.html}\\
\url{http://www.gtkmm.org/docs/gtkmm-2.4/docs/tutorial/html/chapter-basics.html}

\subsection{Részletek sorról sorra}

Vegyük a példaprogramokat szó szerint sorról sorra górcsõ alá.

\begin{enumerate}
 \item[1] A \textit{header} fájlok beszerkesztésének különbözõségeirõl az elõzõ részben esett szó, így erre itt nem térnünk ki.

 \item[3] A \texttt{main} függvény a programunk belépési pontja, azaz itt kezdõdik meg a futtatás. A függvény paramétereirõl részletesebben Vomberg István ``Hello world!'' címû cikksorozatának második részében lehet olvasni.

 \item[5] A \textit{C} nyelvi verzióban kénytelenek vagyunk kicsit korábban deklarálni azt a változót, ami ebben az esetben \textit{widget}ünk címét tartalmazza majd, mivel az \textit{ISO C90} szabvány még nem, majd csak az \textit{ISO C99} támogatja a blokkon belül a kifejezés után elhelyezett változódeklarációkat. Megjegyzendõ, hogy \textit{3.0}-nál gorábbi \textit{gcc} esetén is problémába ütköznénk a \textit{C++} példában használt módszerrel, így a \textit{C} nyelvû kódokban a biztonság kedvéért maradunk a hagyományoknál, azaz lokális változók deklarációja csak blokkok kezdetén szerepel.

 \item[7] Eljutottunk végre az elsõ \textit{GTK} specifikus híváshoz, mely funkcionalitásában, azonos mégis van köztük árnyalatnyi különbség. A \textit{GTK+}-os verzióban mind az \texttt{argc}, mind az \texttt{argv} változó címét adjuk át, biztosítandó azt, hogy az init függvény a \textit{GTK}-nak szóló paramétereket el tudja távolítani a tömbböl és azok számával csökkenteni tudja \texttt{argc} értékét. Erre a \textit{C++}-os változat esetén csak azért nincs szükség, mert --még ha nem is látszik-- mindkét változóra referencia adódik át a \texttt{Gtk::Main} konstruktorának. A \textit{GTK} által értelmezett parancssori paramétereket foglalja össze a http://library.gnome.org/devel/gtk/stable/gtk-running.html oldal.

 \item[9] Elsõ \textit{widget}ünk létrehozása. A \textit{C}-s, illetve \textit{C++}-os nevezéktannak megfelelõen létezik minden \textit{widget}típushoz létezik konstruktor, elõbbi esetben \texttt{gtk\_}\textit{widgetnév}\texttt{\_new} függvény, míg utóbbi esetben \texttt{Gtk::}\textit{WidgetNév}\texttt{::}\textit{WidgetNév} konstruktor formájában. A különbség nem is annyira az nevekben, mintsem a memóriakezelésben rejlik, hiszen egy újjolag allokált objektumot kapunk \textit{C} esetén, aminek a felszabadításáról magunknak kell gondoskodnunk, míg a \textit{C++} a tõle megszokott módon felszabadítja a lokális változókat. Ezen a helyzeten csak a korábban már említett lebegõ referencia bonyolít avagy egyszerûsít némiképp.

 \item[10] Némi meglepetés érhet bennünket, ezt a sort látván, hiszen elsõ olvasatra nem teljesen nyilvánvaló, hogy miért is van szükség a \textit{C} nyelvû változat esetén az megjelenítõ függvény explicit hívására, és hol marad ez a \textit{C++} változatból.

 \item[12] A megoldás a két --egyéb tekintetekben egyforma-- függvény különbségében rejlik. Ez pedig az, hogy a \texttt{Gtk::Main::run} a paraméterként kapott \textit{widget} (jelen esetben \textit{window}) esetén meghívja annak \texttt{show} metódusát. Az azonosságról annyit, hogy a hívások a --korábban már részletezett-- \textit{GTK main loop}ot indítják, azaz itt kezdõdik meg az az eseményvezérelt szakasz, mely a \texttt{gtk\_main\_quit}, illetve \texttt{Gtk::Main::quit} hívásokkal ér véget.

 \item[14] Visszatérési értékünk mindkét esetben 0, amivel rendszerint azt jelezzük a hívó félnek, hogy a futás rendben lezajlott.
\end{enumerate}

\subsection{Vágyaink ablaka}

\subsubsection{Fordítás és linkelés}

A korábbiakhoz hasonlóan az alábbi parancssorok segítségével fordíthatóak e\-lem\-zett programjaink:

\fontsize{8pt}{8pt}
\ \\
\texttt{gcc gtk\_window.c -o gtk\_window \`{}pkg-config {-}-cflags {-}-libs gtk+-2.0}
\ \\
\texttt{g++ gtkmm\_window.cc -o gtkmm\_window \`{}pkg-config gtkmm-2.4 {-}-cflags {-}-libs\`{}}

\subsubsection{Futtatás}

Próbálkozzunk ezúttal is a \texttt{./gtk\_window}, illetve a \texttt{./gtkmm\_window} paranccsokkal abban a könyvtárban, ahol a fordítást elkövettük.

\subsubsection{Eredmény}

Bármily hihetetlen ezúttal sem történik semmi egyéb, mint az elõzõ alkalommal. Remélhetõleg azonban a különbség mégis érzékelhetõ annyiban, hogy legutóbb a meglepetéssel teli borzongást ablakunk váratlan felbukkanása, míg most a bennünk szikraként felvillanó megértés okozza.

\nocite{gtktut}
\nocite{gtkmmtut}
\nocite{ggad}
\nocite{gtktutmagy}

\addcontentsline{toc}{section}{Hivatkozások}
\bibliography{1}
\bibliographystyle{plain}


\end{document}
 
