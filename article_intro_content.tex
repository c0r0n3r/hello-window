\section{Bevezetés}

A cikksorozat ezen első részében a \textit{GTK+}/\textit{gtkmm} programozás szempontjából teljesen az alapokról indulunk, de feltételezünk némi jártassságot a \textit{C}, illetve \textit{C++} nyelvű programozás, illetve a \textit{Linux} alatti fejlesztés terén. Utóbbiak tekintetében javasolt Vomberg István, Programozás Linux környezetben című cikksorozatának tanulmányozása, hisz számos területet érintünk az ott tárgyaltak közül anélkül, hogy itt részletekbe menő kifejtésük megtörténne.

\section{Összehasonlítás}

Mielőtt a kódolás technikai részleteire rátérnénk, tegyünk egy rövid kitérőt a tisztánlátás érdekében és hasonlítsuk össze a két felületprogramozási nyelv alapvető tulajdonságait:\vspace{16pt}

\begin{table}[H]
\begin{center}
\begin{tabular}[t]{l c c}
                                       & \textbf{\textit{GTK+}}            & \textbf{\textit{gtkmm}}  \\\\
\textbf{Felhasználási terület:}        & GUI fejlesztés                    & GUI fejlesztés   \\\\
\textbf{Implementáció nyelve:}         & C                                 & C++              \\\\
\textbf{Implementáció módja:}          & natív                             & wrapper          \\\\
\textbf{Objektumorinentált}            &                                   &                  \\
\textbf{technikák használata:}         & közvetett                         & natív            \\\\
\textbf{Típusellenőrzés:}              & futási időben                     & fordításai dőben \\\\
\textbf{Licenc:}                       & LGPL                              & LGPL             \\\\
\textbf{Ismertebb projektek:}          & GNOME,                            & GNOME,                   \\
                                       & Evolution, Firefox, Gimp, \dots   & GParted, Inkscape, \dots \\
\end{tabular}
\caption{A \textit{GTK+} és \textit{gtkmm} tulajdonságainak összehasonlítása}
\end{center}
\end{table}


\subsection{GTK+ vs. gtkmm}
Ahogy az a fentiekbő is látszik a a \textit{C++} nyelvű változatnak megvannak a maga komoly előnyei. Ezek közül talán a legfontosabb, hogy a nyelv nyújtotta módszereket, mint például az örököltetés, itt közvetlenül használhatjuk ki. Ez természetesen nem jelenti azt, hogy a \textit{GTK+} esetén erre ne lenne lehetőségünk, ugyanakkor meg kell jegyezni, hogy míg a \textit{gtkmm} esetén ez jétszi könnyedséggel megtehető, addig az eredeti változat alkalmazásával ez kissé körülményes. Egy másik megfontolandó érv a típusbiztosság, melynek előnyeit nem lehet eléggé hangsúlyozni, hiszen hosszú órák hibakeresésétől óvhat meg minket. A \textit{GTK+} a \textit{GObject} révén --melyre egy későbbi részben részletesebben is foglalkozunk majd-- rendelkezik egy frappáns mechanizmussal, mely lehetővé teszi a futásidejű típusellenőrzést a \textit{widget}ek esetén, de nem vetekedhet a \textit{C++} nyújtotta fordítási idejű hibaüzenetekkel.

Megfeledkezni azonban nem lehet a tényről, hogy a \textit{C++} fordító közel sem olyan gyakran áll rendelkezésre, mint azt gondolnánk. Számos olyan terület létezik ugyanis, melyek esetén alapvető megkötés a \textit{C} nyelv. Megemlítendő továbbá, hogy a \textit{gtkmm} nem az egyetlen port, hiszen létezik többek között \textit{python} (\textit{pyGTK}), \textit{perl} (gtk2-perl), \textit{ruby}, \textit{java} nyelvű változat is.

\subsection{Kódszervezés}
Elöljáróban fontos lehet még tudni a nyelvet megvalósító implementáció szervezéséről, hogy példaértéküen választja szét a funkcinalitás egyes elemeit több különálló, jól elhatárolt részegységre, melyek ugyan támaszkodnak egymásra, de a megoldás nagyban elősegíti a rugalmasságot és a portabilitást. A \textit{GDK} (\textit{GIMP Drawing Kit}) felelős a rajzolási primitívek megvalóításáér, tulajdonképpen nem egyéb, mint egy wrapper az ablakozó rendszer köré. Hasznossága abban áll, hogy amennyiben sikerül portolni azt egy új grafikus környezetre, akkor a \textit{GTK+} máris működőképessé válhat. A \textit{GObject}, mely a \textit{GLib} része minden widget ``ősosztálya'', ugyanakkor saját eszközök alapkövévé is thetjük, hisz egyebek mellett lehetővé tesz referenciaszálálást, futásidejű típusellenőrzést, tulajdonságok hozzárendelését és azok értékének futásidőben történő változtatását.

\subsection{GLib}
A GLib maga egy önálló függvénykönyvtár, mely számos hasznos --a \textit{C} nyelv elemeként nem létező-- programozói segldeszközt tartalmaz. Ezek közül a leggyakrabban hasznátak az alábbiak:

\begin{description}
 \item[Alkalmazásfejlsztési támogatás] szálak, aszinkron kommunikáció a szálak között, dinamikus modulbetöltés, memória-, pipe-, socket-, fájlkezelés, többszintű logolás
 \item[Fejlesztői segédeszközök] sztring-, dátum-, időkezelés, karakterkonverziós eszközök, parancssori paraméterek, XML, .ini, bookmar fájlok feldolgozása, időzítők, reguláris kifejezések
 \item[Adattípusok] láncolt listák, fák, asszociatív tömbök, szekvenciák, sorok, dinamikusan méretezhető tömbök
\end{description}

Itt is létezik \textit{C++} nyelvű változat, ahogy a \textit{GTK+} esetén is, ám itt a wrapper csak akkor készül el, ha a C++ standard könyvtára nem tartalmaz azonos funkcionalitású eszközt.

\section{Első ablakunk}

Ennyi bevezetés után épp ideje már némi kódot látnunk és azt górcső alá vennünk némiképp. Rögvest célszerű hozzátenni, hogy az alabbi --amúgy a gyakorlatban nem túl komoly hasznosságú-- példa teljes részletességel történő kommentálása önmagában is egy cikksorozat témája lehetne. Szoritkozzunk most ennek okán csak a lényegre:

\subsection{A kód}

\lstinputsources
{sources/window_minimal.c}
{sources/window_minimal.cc}
{Minimálisan szükséges kód \textit{GTK+}/\textit{gtkmm} használatához}
{lst:windowminimal}


A fenti példaprogramok forrásfájljai és azok \textit{GTK+}/\textit{gtkmm} weblapjáról, az alábbi linkeken:

\begin{verbatim}
http://www.flosszine.org/
http://library.gnome.org/devel/gtk-tutorial/stable/c39.html
http://www.gtkmm.org/docs/gtkmm-2.4/docs/tutorial/html/chapter-basics.html
\end{verbatim}

\subsection{Némi magyarázat}

A lefordított programok természetesen ugyanazt az eredményt adják, de erről egy picikét később. Vegyük most szemügyre közelebbről a forráskódot amit a nagyfokó hasonlóság ellenére mutat eltéréseket is.

\subsubsection{Projektek különbözőségéből adódó eltérések}

A legtöbb nyílt forrású projekt esetén igaz, hogy a kódolás és kódszervezés során egy meghatározott konvenciót követnek, ám amint ez a korábbi példából is látszik, egy olyan méretű projekt esetén, mint a \textit{GNOME} az egyes részterületeken lehetnek eltérések.

\begin{description}
 \item[Forráskód formázása] A \textit{GTK+} fejlesztői a \textit{GNU coding standard} irányelveit alkalmazzák, míg a \textit{gktmmm} ettől minimális mértékben eltérő változat az alkalmaz.

 \item[Fejécfájlok helye] Mint az későbbiekben megfigyelhető lesz a \textit{GTK+} \textit{header}ek esetén a fájloknak van egy \textit{gtk} prefixe, ugynakkor a \textit{gtkmm}-nél eznem használatos. Ez egyébiránt illeszkedig a nevezéktannál tapsztaltakkal.
 \end{description}

\subsubsection{Programozási nyelv okozta sajátosságok}

\begin{description}
 \item[Nevezéktan] A \textit{GTK+} minden saját makrót/függvényt \texttt{GTK}/\texttt{gtk} prefixszel lát el (\textit{GLib} esetén ez pusztán csak egy kis/nagy \texttt{g} betű), sőt egy adott részterület --például egy \textit{widget}-- saját ``névterülettel'' is rendelkezhet, azaz újabb prefixet vezethet be. Ezeket egymástól, illetve a ``valódi'' funkciót jelölő nevektől \texttt{\_} (aláhuzás) jellel választják el. A C++ wrapper kódát olvasva láthatjuk, hogy kihasználva a kézenfekvő nyelvi lehetőséget, a prefixek szerepét a névterek veszik át, annyi különbséggel, hogy ezek neveiben csak az első betű nagy.
 \item[Nyelvhez kötődő módszerek] A minapéldában megfigyelhető (az azonos funkciójú sorok párbaállítása révén), hogy a \textit{C++} kód némileg egyszerűbb, hiszen az ablakunk létrehozásakor nem kell a window típusára (\textit{toplevel}) vonatkozó paramétert megadnunk, azonos helyen lehet a változó deklarációja és első felhasználása. Külön is említésre méltó, bár a \textit{C++} prgramozók számára nem meglepő, hogy a main függvényből való kilépéskor a \textit{gtkmm} változat windowja felszabadul, míg a \textit{GTK+} verzió esetén ez csak azért történik meg, mert magából a programból is kiléptünk egyúttal.
\end{description}

\subsection{Vágyaink ablaka}

\subsubsection{Fordítás és linkelés}

Az alábbi parancssorok segítségével fordíthatóak elkészült programjaink:

\fontsize{8pt}{8pt}
\ \\
\texttt{gcc gtk\_window.c -o gtk\_window \`{}pkg-config {-}-cflags {-}-libs gtk+-2.0}
\ \\
\texttt{g++ gtkmm\_window.cc -o gtkmm\_window \`{}pkg-config gtkmm-2.4 {-}-cflags {-}-libs\`{}}
\\

Segítségünkre a \texttt{pkg-config} parancs van, hogy a \textit{gcc}-nek a megfelelő paramétereket meg tudjuk adni. A \texttt{--cflags} paraméter hatására a fordításhoz, míg a \texttt{--libs} eredményeképp a linkeléshez szükséges opciókat kapjuk vissza. A parancs két \texttt{\`} (backtick) közé zárt. aminek hatsára annak kimenete része lesz a fordító parancssorának, amivel pont az áhytott hatást érjük el.

\subsubsection{Futtatás}

Ezel után már csak az örömteli pillanat van hátra, mikor is két különböző nyelven és függvénykönyvtárral lekódolt teljesen azonos funkciójú programunkat lefuttatjuk a \texttt{./gtk\_window}, illetve a \texttt{./gtkmm\_window} paranccsal.

\subsubsection{Eredmény}

\textit{Voil\`{a}!} Túlvagyunk két ablak --vagyis egy Windows-- lekódolásán. Ami eddi is közismert volt, újabb bizonyságot nyert, a Windows kódja lehet, hogy elegáns és egyszerű. ám az eredmény mégis hasznavehetetlen. Az utóbbin fogunk segíteni a következő részekben.
