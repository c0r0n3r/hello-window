\section{Fejlesztési sajátosságok}

\subsection{Projektek különbözőségéből adódó eltérések}

A legtöbb nyílt forrású projekt esetén igaz, hogy a kódolás és kódszervezés során egy meghatározott konvenciót követnek, ám amint ez a korábbi példából is látszik, egy olyan méretű projekt esetén, mint a \textit{GNOME} az egyes részterületeken lehetnek eltérések.

\paragraph{Forráskód formázása}

A \textit{GTK+} fejlesztői a \textit{GNU coding standard} irányelveit alkalmazzák, míg a \textit{gktmm} ettől minimális mértékben eltérő változat az alkalmaz.

\paragraph{Fejlécfájlok helye}

Mint az későbbiekben megfigyelhető lesz a \textit{GTK+} \textit{header}ek esetén a fájloknak van egy \textit{gtk} prefixe, ugyanakkor a \textit{gtkmm}-nél ez nem használatos. Ez egyébiránt illeszkedik a nevezéktannál tapasztaltakkal.

A lefordított programok természetesen ugyanazt az eredményt adják, de erről egy picikét később. Vegyük most szemügyre közelebbről a forráskódot amit a nagyfokú hasonlóság ellenére mutat eltéréseket is.

\section{A kód}
\label{sec:gtkminimal}
\label{sec:gtkmmminimal}

Az ismétlés kedvéért -- no meg persze, hogy kéznél legyen -- lássuk most az előző számban már bemutatott példaprogramokat.

\lstinputsourcess
{sources/gtk_minimal.c}
{sources/gtk_minimal.cc}
{sources/gtk_minimal.py}
{Minimálisan szükséges kód \textit{GTK+}/\textit{gtkmm} használatához}
{lst:gtkminimal}

A fenti példaprogramok \textit{C/C++} nyelvű forrásfájljai, illetve azok eredetijei, a \textit{FLOSSzine}, valamint a \textit{GTK+}/\textit{gtkmm} oldalain az alábbi linkeken érhetőek el:
\ \\\\
\url{http://library.gnome.org/devel/gtk-tutorial/stable/c39.html}\\
\url{http://www.gtkmm.org/docs/gtkmm-2.4/docs/tutorial/html/chapter-basics.html}

\subsection{Részletek sorról sorra}

Vegyük a példaprogramokat szó szerint sorról sorra górcső alá.

\begin{enumerate}
 \item[\ref{gtkminimalc:include}] A \textit{header} fájlok beszerkesztésének különbözőségeiről az előző részben esett szó, így erre itt nem térnünk ki.

 \item[\ref{gtkminimalc:main}] A \texttt{main} függvény a programunk belépési pontja, azaz itt kezdődik meg a futtatás. A függvény paramétereiről részletesebben Vomberg István ''Hello world!'' című cikksorozatának második részében lehet olvasni.

 \item[\ref{gtkminimalc:windowdeclare}] A \textit{C} nyelvi verzióban kénytelenek vagyunk kicsit korábban deklarálni azt a változót, ami ebben az esetben \textit{widget}ünk címét tartalmazza majd, mivel az \textit{ISO C90} szabvány még nem, majd csak az \textit{ISO C99} támogatja a blokkon belül a kifejezés után elhelyezett változódeklarációkat. Megjegyzendő, hogy \textit{3.0}-nál gorábbi \textit{gcc} esetén is problémába ütköznénk a \textit{C++} példában használt módszerrel, így a \textit{C} nyelvű kódokban a biztonság kedvéért maradunk a hagyományoknál, azaz lokális változók deklarációja csak blokkok kezdetén szerepel.

 \item[\ref{gtkminimalc:gtkmain}] Eljutottunk végre az első \textit{GTK} specifikus híváshoz, mely funkcionalitásában, azonos mégis van köztük árnyalatnyi különbség. A \textit{GTK+}-os verzióban mind az \texttt{argc}, mind az \texttt{argv} változó címét adjuk át, biztosítandó azt, hogy az init függvény a \textit{GTK}-nak szóló paramétereket el tudja távolítani a tömbböl és azok számával csökkenteni tudja \texttt{argc} értékét. Erre a \textit{C++}-os változat esetén csak azért nincs szükség, mert -- még ha nem is látszik -- mindkét változóra referencia adódik át a \texttt{Gtk::Main} konstruktorának. A \textit{GTK} által értelmezett parancssori paramétereket foglalja össze a http://library.gnome.org/devel/gtk/stable/gtk-running.html oldal.

 \item[\ref{gtkminimalcc:windowdeclare}] Első \textit{widget}ünk létrehozása. A \textit{C}-s, illetve \textit{C++}-os nevezéktannak megfelelően létezik minden \textit{widget}típushoz létezik konstruktor, előbbi esetben \texttt{gtk\_}\textit{widgetnév}\texttt{\_new} függvény, míg utóbbi esetben \texttt{Gtk::}\textit{WidgetNév}\texttt{::}\textit{WidgetNév} konstruktor formájában. A különbség nem is annyira az nevekben, mintsem a memóriakezelésben rejlik, hiszen egy újjolag allokált objektumot kapunk \textit{C} esetén, aminek a felszabadításáról magunknak kell gondoskodnunk, míg a \textit{C++} a tőle megszokott módon felszabadítja a lokális változókat. Ezen a helyzeten csak a korábban már említett lebegő referencia bonyolít avagy egyszerűsít némiképp.

 \item[\ref{gtkminimalc:windowshow}] Némi meglepetés érhet bennünket, ezt a sort látván, hiszen első olvasatra nem teljesen nyilvánvaló, hogy miért is van szükség a \textit{C} nyelvű változat esetén az megjelenítő függvény explicit hívására, és hol marad ez a \textit{C++} változatból.

 \item[\ref{gtkminimalc:gtkrun}] A megoldás a két -- egyéb tekintetekben egyforma -- függvény különbségében rejlik. Ez pedig az, hogy a \texttt{Gtk::Main::run} a paraméterként kapott \textit{widget} (jelen esetben \textit{window}) esetén meghívja annak \texttt{show} metódusát. Az azonosságról annyit, hogy a hívások a -- korábban már részletezett -- \textit{GTK main loop}ot indítják, azaz itt kezdődik meg az az eseményvezérelt szakasz, mely a \texttt{gtk\_main\_quit}, illetve \texttt{Gtk::Main::quit} hívásokkal ér véget.

 \item[\ref{gtkminimalc:return}] Visszatérési értékünk mindkét esetben 0, amivel rendszerint azt jelezzük a hívó félnek, hogy a futás rendben lezajlott.
\end{enumerate}

\subsection{Fordítás és linkelés}

A korábbiakhoz hasonlóan az alábbi parancssorok segítségével fordíthatóak e\-lem\-zett programjaink:

\lstcompiles
{gtk_minimal.c}{gtk_minimal}
{gtkmm_minimal.cc}{gtkmm_minimal}

\subsection{Futtatás}

Próbálkozzunk ezúttal is a \texttt{./gtk\_minimal}, illetve a \texttt{./gtkmm\_minimal} paranccsokkal abban a könyvtárban, ahol a fordítást elkövettük.

\subsection{Eredmény}

Bármily hihetetlen ezúttal sem történik semmi egyéb, mint az előző alkalommal. Remélhetőleg azonban a különbség mégis érzékelhető annyiban, hogy legutóbb a meglepetéssel teli borzongást ablakunk váratlan felbukkanása, míg most a bennünk szikraként felvillanó megértés okozza.
