A lefordított programok természetesen ugyanazt az eredményt adják, de erről egy picikét később. Vegyük most szemügyre közelebbről a forráskódot amit a nagyfokú hasonlóság ellenére mutat eltéréseket is.

\section{A kód}
\label{sec:gtkminimal}
\label{sec:gtkmmminimal}

Az ismétlés kedvéért -- no meg persze, hogy kéznél legyen -- lássuk most az előző számban már bemutatott példaprogramokat.

\lstinputsources
{sources/window_minimal.c}
{sources/window_minimal.cc}
{Minimálisan szükséges kód \textit{GTK+}/\textit{gtkmm} használatához}
{lst:windowminimal}

A fenti példaprogramok \textit{C/C++} nyelvű forrásfájljai, illetve azok eredetijei, a \textit{FLOSSzine}, valamint a \textit{GTK+}/\textit{gtkmm} oldalain az alábbi linkeken érhetőek el:
\ \\\\
\url{http://library.gnome.org/devel/gtk-tutorial/stable/c39.html}\\
\url{http://www.gtkmm.org/docs/gtkmm-2.4/docs/tutorial/html/chapter-basics.html}

\subsection{Részletek sorról sorra}

Vegyük a példaprogramokat szó szerint sorról sorra górcső alá.

\begin{enumerate}
 \item[1] A \textit{header} fájlok beszerkesztésének különbözőségeiről az előző részben esett szó, így erre itt nem térnünk ki.

 \item[3] A \texttt{main} függvény a programunk belépési pontja, azaz itt kezdődik meg a futtatás. A függvény paramétereiről részletesebben Vomberg István ``Hello world!'' című cikksorozatának második részében lehet olvasni.

 \item[5] A \textit{C} nyelvi verzióban kénytelenek vagyunk kicsit korábban deklarálni azt a változót, ami ebben az esetben \textit{widget}ünk címét tartalmazza majd, mivel az \textit{ISO C90} szabvány még nem, majd csak az \textit{ISO C99} támogatja a blokkon belül a kifejezés után elhelyezett változódeklarációkat. Megjegyzendő, hogy \textit{3.0}-nál gorábbi \textit{gcc} esetén is problémába ütköznénk a \textit{C++} példában használt módszerrel, így a \textit{C} nyelvű kódokban a biztonság kedvéért maradunk a hagyományoknál, azaz lokális változók deklarációja csak blokkok kezdetén szerepel.

 \item[7] Eljutottunk végre az első \textit{GTK} specifikus híváshoz, mely funkcionalitásában, azonos mégis van köztük árnyalatnyi különbség. A \textit{GTK+}-os verzióban mind az \texttt{argc}, mind az \texttt{argv} változó címét adjuk át, biztosítandó azt, hogy az init függvény a \textit{GTK}-nak szóló paramétereket el tudja távolítani a tömbböl és azok számával csökkenteni tudja \texttt{argc} értékét. Erre a \textit{C++}-os változat esetén csak azért nincs szükség, mert -- még ha nem is látszik -- mindkét változóra referencia adódik át a \texttt{Gtk::Main} konstruktorának. A \textit{GTK} által értelmezett parancssori paramétereket foglalja össze a http://library.gnome.org/devel/gtk/stable/gtk-running.html oldal.

 \item[9] Első \textit{widget}ünk létrehozása. A \textit{C}-s, illetve \textit{C++}-os nevezéktannak megfelelően létezik minden \textit{widget}típushoz létezik konstruktor, előbbi esetben \texttt{gtk\_}\textit{widgetnév}\texttt{\_new} függvény, míg utóbbi esetben \texttt{Gtk::}\textit{WidgetNév}\texttt{::}\textit{WidgetNév} konstruktor formájában. A különbség nem is annyira az nevekben, mintsem a memóriakezelésben rejlik, hiszen egy újjolag allokált objektumot kapunk \textit{C} esetén, aminek a felszabadításáról magunknak kell gondoskodnunk, míg a \textit{C++} a tőle megszokott módon felszabadítja a lokális változókat. Ezen a helyzeten csak a korábban már említett lebegő referencia bonyolít avagy egyszerűsít némiképp.

 \item[10] Némi meglepetés érhet bennünket, ezt a sort látván, hiszen első olvasatra nem teljesen nyilvánvaló, hogy miért is van szükség a \textit{C} nyelvű változat esetén az megjelenítő függvény explicit hívására, és hol marad ez a \textit{C++} változatból.

 \item[12] A megoldás a két -- egyéb tekintetekben egyforma -- függvény különbségében rejlik. Ez pedig az, hogy a \texttt{Gtk::Main::run} a paraméterként kapott \textit{widget} (jelen esetben \textit{window}) esetén meghívja annak \texttt{show} metódusát. Az azonosságról annyit, hogy a hívások a -- korábban már részletezett -- \textit{GTK main loop}ot indítják, azaz itt kezdődik meg az az eseményvezérelt szakasz, mely a \texttt{gtk\_main\_quit}, illetve \texttt{Gtk::Main::quit} hívásokkal ér véget.

 \item[14] Visszatérési értékünk mindkét esetben 0, amivel rendszerint azt jelezzük a hívó félnek, hogy a futás rendben lezajlott.
\end{enumerate}

\subsection{Fordítás és linkelés}

A korábbiakhoz hasonlóan az alábbi parancssorok segítségével fordíthatóak e\-lem\-zett programjaink:

\lstcompiles
{gtk_window.c}{gtk_window}
{gtkmm_window.cc}{gtkmm_window}

\subsection{Futtatás}

Próbálkozzunk ezúttal is a \texttt{./gtk\_window}, illetve a \texttt{./gtkmm\_window} paranccsokkal abban a könyvtárban, ahol a fordítást elkövettük.

\subsection{Eredmény}

Bármily hihetetlen ezúttal sem történik semmi egyéb, mint az előző alkalommal. Remélhetőleg azonban a különbség mégis érzékelhető annyiban, hogy legutóbb a meglepetéssel teli borzongást ablakunk váratlan felbukkanása, míg most a bennünk szikraként felvillanó megértés okozza.
